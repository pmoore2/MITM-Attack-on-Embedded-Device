# MITM-Attack-on-Embedded-Device

For this project, I recovered a 16-byte secret from the provided firmware that was encrypted using AES encryption. To recover the secret value, I reverse-engineered the firmware using Ghidra to recover each 16-byte block of the binary file. When reverse engineering the firmware, I was able to recover the main function and the simpleserial_addcmd function. In the main file, I noticed a new command used for simpleserial_addcmd that was not in the `client.py` file. This command was the ‘d’ command, which enabled debug mode on the firmware. I used debug mode to help recover the AES public key to decrypt the secret message in the new firmware.

I wrote a script in Python, `decrypt.py` to loop through every 16-byte block in the binary firmware file and decrypt them using the provided public key until one of them decrypted to an ASCII plaintext. There was only one 16-byte sequence in the file that met this criterion, and those bytes decrypted to the public key. To make this attack more universal to work on other firmwares, I modified the Python script to parse the firmware file to generate the data bytes. Once I acquired the public key from the MITM attack, I knew that I could use this script again to recover the secret message in the new firmware.

To recover the AES encryption public key of the new firmware, I implemented an MITM attack to intercept the decrypt key of the new firmware. The arduino sketch for the MITM attack that I used is found in file `MITM.ino`. I would then use this decrypt key in my Python file that I used before to decrypt every 16-byte sequence in the new firmware file to find the secret message. The MITM attack involved computing a public and private key on an Arduino MKR 1000 and sending it to the `connection.ipynb` file and creating a public key in that file. I then used the public key that I intercepted from the `connection.ipynb` and the arduino private key to compute a shared secret. Then, the arduino intercepted the encrypted decrypt key from the `connection.ipynb` file and used the computed shared secret to decrypt it to give me the decrypt key for the firmware. After performing this attack on the solution firmware, I found the decrypt key and the secret message.

To perform this attack, I connected the GND pin on the chipwhisperer to the GND pin on the arduino. I connected the TX on the arduino to the TX on the chipwhisperer and the RX on the arduino to the RX on the chipwhisperer. Lastly, I connected the nRST pin on the chipwhisperer to the GND pin on the arduino to force the nRST of the chipwhisperer to be low. A picture is attached below of my hardware setup.

![alt text](https://github.com/pmoore2/MITM-Attack-on-Embedded-Device/blob/main/images/MITM_CW.png "Hardware Setup")

The non-privileged Python client programs `connection.ipynb`, `utils.py`, and `client.py` are not provided in this repository. `connection.ipynb` coordinates the ECDH key exchange with the chipwhisperer nano. `utils.py` helper functions for verifying ECDSA signatures and generating pseudorandom values. `client.py` defines functions for performing and analyzing ECDSA operations.
